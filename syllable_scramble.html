<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Syllable Scramble</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: "Segoe UI", sans-serif;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 30px 16px 50px;
      }

      .card {
        background: #fff;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 760px;
        padding: 36px 40px 40px;
      }

      /* Header */
      .header {
        text-align: center;
        margin-bottom: 28px;
      }
      .header h1 {
        font-size: 2rem;
        font-weight: 800;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 6px;
      }
      .header p {
        color: #888;
        font-size: 0.9rem;
      }

      .timer-bar {
        display: flex;
        justify-content: center;
        margin-bottom: 24px;
      }
      .timer {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: #fff;
        font-size: 1.4rem;
        font-weight: 700;
        padding: 8px 28px;
        border-radius: 50px;
        letter-spacing: 2px;
        font-variant-numeric: tabular-nums;
      }

      /* Rules */
      .rules {
        background: #f8f7ff;
        border-left: 4px solid #667eea;
        border-radius: 0 12px 12px 0;
        padding: 16px 20px;
        margin-bottom: 28px;
      }
      .rules h3 {
        color: #667eea;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
      }
      .rules p {
        color: #555;
        font-size: 0.88rem;
        line-height: 1.6;
      }

      .section-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: #999;
        font-weight: 700;
        margin-bottom: 10px;
      }

      /* Desktop pool */
      .pool-wrapper {
        margin-bottom: 30px;
      }

      .syllable-pool {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 48px;
        padding: 12px;
        background: #fafafa;
        border: 2px dashed #ddd;
        border-radius: 14px;
        transition:
          border-color 0.2s,
          background 0.2s;
      }
      .syllable-pool.drag-over {
        border-color: #667eea;
        background: #f0f0ff;
      }

      /* Sticky pool bar (mobile) */
      .sticky-pool-bar {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 50;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 10px 14px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      .sticky-pool-bar .sticky-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: rgba(255, 255, 255, 0.7);
        font-weight: 700;
        margin-bottom: 7px;
      }
      .sticky-pool-bar .syllable-pool {
        background: rgba(255, 255, 255, 0.15);
        border-color: rgba(255, 255, 255, 0.3);
        min-height: 40px;
        padding: 8px 10px;
        gap: 7px;
      }
      .sticky-pool-bar .syllable-pool.drag-over {
        background: rgba(255, 255, 255, 0.28);
        border-color: #fff;
      }
      .sticky-pool-bar .syllable {
        background: rgba(255, 255, 255, 0.25);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        font-size: 0.78rem;
        padding: 6px 11px;
      }

      .sticky-spacer {
        display: none;
      }

      /* Syllables */
      .syllable {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: #fff;
        padding: 7px 14px;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 700;
        cursor: grab;
        user-select: none;
        touch-action: none;
        letter-spacing: 0.5px;
        transition:
          transform 0.15s,
          box-shadow 0.15s,
          opacity 0.2s;
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.35);
      }
      .syllable:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.45);
      }
      .syllable.dragging {
        opacity: 0.35;
        cursor: grabbing;
      }

      /* Touch drag ghost */
      .touch-ghost {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: #fff;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.55);
        transform: translate(-50%, -50%) scale(1.12);
        opacity: 0.93;
        transition: none;
      }

      /* Clues */
      .clues {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .clue-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        background: #f8f7ff;
        border-radius: 14px;
        border: 2px solid transparent;
        transition:
          border-color 0.2s,
          background 0.2s;
      }
      .clue-row.drag-over {
        border-color: #667eea;
        background: #eeeeff;
      }
      .clue-row.solved {
        background: #f0fff4;
        border-color: #52c87a;
      }
      .clue-row.wrong {
        border-color: #e74c3c;
        background: #fff5f5;
      }

      .clue-number {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: #fff;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 800;
        flex-shrink: 0;
      }
      .clue-row.solved .clue-number {
        background: linear-gradient(135deg, #52c87a, #27ae60);
      }

      .clue-text {
        flex: 0 0 160px;
        font-size: 0.92rem;
        color: #444;
        font-weight: 600;
      }
      .clue-syllable-count {
        font-size: 0.75rem;
        color: #aaa;
        flex: 0 0 60px;
      }

      .clue-drop-zone {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        min-height: 36px;
        padding: 6px 10px;
        background: #fff;
        border: 2px dashed #ddd;
        border-radius: 10px;
        align-items: center;
        transition: border-color 0.2s;
      }
      .clue-row.drag-over .clue-drop-zone {
        border-color: #667eea;
      }
      .clue-drop-zone .syllable {
        background: #667eea;
        font-size: 0.8rem;
        padding: 5px 10px;
        cursor: pointer;
      }
      .clue-drop-zone .syllable:hover {
        background: #e74c3c;
        transform: none;
      }
      .clue-drop-zone .placeholder {
        color: #ccc;
        font-size: 0.8rem;
        font-style: italic;
        pointer-events: none;
      }

      .solve-check {
        flex-shrink: 0;
        font-size: 1.2rem;
        display: none;
      }
      .clue-row.solved .solve-check {
        display: block;
      }

      .wrong-shake {
        animation: shake 0.4s ease;
      }
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        20% {
          transform: translateX(-6px);
        }
        40% {
          transform: translateX(6px);
        }
        60% {
          transform: translateX(-4px);
        }
        80% {
          transform: translateX(4px);
        }
      }

      /* Actions */
      .actions {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-top: 28px;
      }
      .btn {
        padding: 10px 24px;
        border-radius: 10px;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        border: none;
        transition:
          transform 0.15s,
          box-shadow 0.15s;
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      }
      .btn:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none !important;
        box-shadow: none !important;
      }
      .btn-primary {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: #fff;
      }
      .btn-outline {
        background: transparent;
        border: 2px solid #ccc;
        color: #888;
      }

      .status-msg {
        text-align: center;
        margin-top: 12px;
        font-size: 0.88rem;
        font-weight: 600;
        color: #e74c3c;
        min-height: 20px;
        opacity: 0;
        transform: translateY(-4px);
        transition:
          opacity 0.2s,
          transform 0.2s;
      }
      .status-msg.visible {
        opacity: 1;
        transform: translateY(0);
      }

      /* Modal */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
        z-index: 100;
        padding: 16px;
      }
      .modal-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      .modal {
        background: #fff;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        padding: 40px 36px;
        max-width: 420px;
        width: 100%;
        text-align: center;
        transform: scale(0.85);
        transition: transform 0.3s;
      }
      .modal-overlay.active .modal {
        transform: scale(1);
      }
      .modal-icon {
        font-size: 3rem;
        margin-bottom: 12px;
      }
      .modal h2 {
        font-size: 1.8rem;
        font-weight: 800;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
      }
      .modal p {
        color: #666;
        margin-bottom: 6px;
        font-size: 0.95rem;
      }
      .modal .final-time {
        font-size: 2.2rem;
        font-weight: 900;
        color: #667eea;
        margin: 16px 0 24px;
        letter-spacing: 2px;
      }
      .modal-btns {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
      }

      /* Mobile */
      @media (max-width: 600px) {
        body {
          padding: 16px 10px 60px;
        }
        .card {
          padding: 20px 16px 28px;
          border-radius: 16px;
        }
        .header h1 {
          font-size: 1.5rem;
        }
        .clue-row {
          flex-wrap: wrap;
        }
        .clue-text {
          flex: 0 0 100%;
        }
        .clue-syllable-count {
          flex: 0 0 auto;
        }
      }

      /* Sticky bar â€” hidden by default, shown by JS when pool scrolls out of view */
      .sticky-pool-bar.is-visible {
        display: block;
      }
      .sticky-spacer.is-visible {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Sticky pool (mobile only) -->
    <div class="sticky-pool-bar" id="stickyBar">
      <div class="sticky-label">Syllable Pool</div>
      <div class="syllable-pool" id="stickyPool"></div>
    </div>
    <div class="sticky-spacer" id="stickySpacer"></div>

    <div class="card">
      <div class="header">
        <h1>ðŸ§© Syllable Scramble</h1>
        <p>Group syllables to form words matching each clue</p>
      </div>

      <div class="timer-bar">
        <div class="timer" id="timer">00:00</div>
      </div>

      <div class="rules">
        <h3>ðŸ“– How to Play</h3>
        <p>
          Below are <strong>22 syllables</strong> and <strong>6 clues</strong>. Drag syllables in
          order onto the matching clue to build a word. The number in parentheses tells you how many
          syllables each answer has. Each syllable is used exactly once. You must place
          <em>all</em> syllables before checking. Good luck!
        </p>
      </div>

      <!-- Desktop pool -->
      <div class="pool-wrapper">
        <div class="section-label">Syllable Pool</div>
        <div class="syllable-pool" id="pool"></div>
      </div>

      <div class="section-label">Clues</div>
      <div class="clues" id="clues"></div>

      <div class="actions">
        <button class="btn btn-outline" onclick="resetPuzzle()">â†º Reset</button>
        <button class="btn btn-primary" id="checkAllBtn" onclick="checkAll()">âœ“ Check All</button>
      </div>
      <div id="statusMsg" class="status-msg"></div>
    </div>

    <!-- Winner Modal -->
    <div class="modal-overlay" id="winModal">
      <div class="modal">
        <div class="modal-icon">ðŸŽ‰</div>
        <h2>Puzzle Solved!</h2>
        <p>You completed Syllable Scramble in</p>
        <div class="final-time" id="finalTime">00:00</div>
        <div class="modal-btns">
          <button class="btn btn-outline" onclick="closeModal()">Close</button>
          <button class="btn btn-primary" onclick="resetPuzzle()">â†º Play Again</button>
        </div>
      </div>
    </div>

    <script>
      const SYLLABLES = [
        "A",
        "AC",
        "AD",
        "BUT",
        "CUP",
        "DEM",
        "HES",
        "I",
        "IC",
        "IS",
        "IS",
        "LA",
        "LAZ",
        "LEG",
        "LI",
        "MIN",
        "TANT",
        "TER",
        "TION",
        "TOR",
        "TRA",
        "U",
      ]

      const CLUES = [
        { id: 1, text: "Yellow flower", count: 3, answer: ["BUT", "TER", "CUP"] },
        { id: 2, text: "Director", count: 5, answer: ["AD", "MIN", "IS", "TRA", "TOR"] },
        { id: 3, text: "Lapis ___", count: 3, answer: ["LAZ", "U", "LI"] },
        { id: 4, text: "Lawmaking", count: 4, answer: ["LEG", "IS", "LA", "TION"] },
        { id: 5, text: "Undecided", count: 3, answer: ["HES", "I", "TANT"] },
        { id: 6, text: "Scholar", count: 4, answer: ["AC", "A", "DEM", "IC"] },
      ]

      // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let pool = [...SYLLABLES]
      let clueSlots = CLUES.map(() => [])
      let solved = CLUES.map(() => false)
      let timerInterval, startTime

      // Mouse drag state
      let dragSyl = null,
        dragSource = null

      // Touch drag state
      let touchGhost = null
      let touchDragSyl = null,
        touchDragSource = null,
        touchDragIdx = null
      let touchOriginEl = null
      let lastHighlighted = null
      let touchMoved = false

      // â”€â”€ Timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const pad = (n) => String(n).padStart(2, "0")
      function formatTime(ms) {
        const s = Math.floor(ms / 1000)
        return pad(Math.floor(s / 60)) + ":" + pad(s % 60)
      }
      function startTimer() {
        startTime = Date.now()
        clearInterval(timerInterval)
        timerInterval = setInterval(() => {
          document.getElementById("timer").textContent = formatTime(Date.now() - startTime)
        }, 500)
      }
      function stopTimer() {
        clearInterval(timerInterval)
      }

      // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function isMobile() {
        return window.innerWidth <= 600
      }

      function updateStickyHeight() {
        const bar = document.getElementById("stickyBar")
        const spacer = document.getElementById("stickySpacer")
        if (bar && spacer) spacer.style.height = bar.offsetHeight + 4 + "px"
      }

      // â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function render() {
        renderPools()
        renderClues()
      }

      function renderPools() {
        // Render into both pool elements; CSS hides whichever isn't active
        ;["pool", "stickyPool"].forEach((id) => {
          const el = document.getElementById(id)
          if (!el) return
          el.innerHTML = ""
          if (pool.length === 0) {
            const msg = document.createElement("span")
            msg.style.cssText = "font-size:0.82rem;font-style:italic;"
            msg.style.color = id === "stickyPool" ? "rgba(255,255,255,0.6)" : "#ccc"
            msg.textContent = "All syllables placed âœ“"
            el.appendChild(msg)
            return
          }
          pool.forEach((syl, idx) => el.appendChild(makeSylEl(syl, "pool", idx)))
        })
      }

      function renderClues() {
        const cluesEl = document.getElementById("clues")
        cluesEl.innerHTML = ""
        CLUES.forEach((clue, ci) => {
          const row = document.createElement("div")
          row.className = "clue-row" + (solved[ci] ? " solved" : "")
          row.dataset.clue = ci

          // Mouse drag-over
          row.addEventListener("dragover", (e) => {
            e.preventDefault()
            row.classList.add("drag-over")
          })
          row.addEventListener("dragleave", () => row.classList.remove("drag-over"))
          row.addEventListener("drop", (e) => {
            e.preventDefault()
            row.classList.remove("drag-over")
            dropOnClue(ci)
          })

          row.innerHTML = `
      <div class="clue-number">${clue.id}</div>
      <div class="clue-text">${clue.text}</div>
      <div class="clue-syllable-count">(${clue.count} syl.)</div>
    `

          const dz = document.createElement("div")
          dz.className = "clue-drop-zone"
          dz.dataset.clue = ci
          if (clueSlots[ci].length === 0) {
            dz.innerHTML = '<span class="placeholder">Drop syllables hereâ€¦</span>'
          } else {
            clueSlots[ci].forEach((syl, si) => dz.appendChild(makeSylEl(syl, ci, si)))
          }
          row.appendChild(dz)

          const chk = document.createElement("span")
          chk.className = "solve-check"
          chk.textContent = "âœ…"
          row.appendChild(chk)

          cluesEl.appendChild(row)
        })
        updateCheckAllBtn()
      }

      // â”€â”€ Syllable element factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function makeSylEl(syl, source, idx) {
        const el = document.createElement("div")
        el.className = "syllable"
        el.textContent = syl
        el.draggable = true

        // Mouse drag
        el.addEventListener("dragstart", () => {
          dragSyl = syl
          dragSource = source
          el.classList.add("dragging")
        })
        el.addEventListener("dragend", () => el.classList.remove("dragging"))

        // Click (desktop shortcut / tap fallback)
        el.addEventListener("click", () => {
          if (touchMoved) return // was a touch drag, ignore click
          handleTap(syl, source, idx)
        })

        // Touch drag
        el.addEventListener("touchstart", onTouchStart, { passive: false })

        return el
      }

      function handleTap(syl, source, idx) {
        if (source === "pool") {
          const ci = clueSlots.findIndex((s, i) => !solved[i] && s.length < CLUES[i].count)
          if (ci >= 0) {
            pool.splice(pool.indexOf(syl), 1)
            clueSlots[ci].push(syl)
            render()
          }
        } else {
          clueSlots[source].splice(idx, 1)
          pool.push(syl)
          render()
        }
      }

      // â”€â”€ Touch drag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function onTouchStart(e) {
        if (e.touches.length !== 1) return
        e.preventDefault()
        touchMoved = false

        const el = e.currentTarget
        const touch = e.touches[0]

        touchDragSyl = el.textContent.trim()
        const dz = el.closest(".clue-drop-zone")
        if (dz) {
          touchDragSource = parseInt(dz.dataset.clue)
          touchDragIdx = Array.from(dz.querySelectorAll(".syllable")).indexOf(el)
        } else {
          touchDragSource = "pool"
          touchDragIdx = null
        }
        touchOriginEl = el

        // Create floating ghost
        touchGhost = document.createElement("div")
        touchGhost.className = "touch-ghost"
        touchGhost.textContent = touchDragSyl
        document.body.appendChild(touchGhost)
        positionGhost(touch.clientX, touch.clientY)

        el.classList.add("dragging")

        document.addEventListener("touchmove", onTouchMove, { passive: false })
        document.addEventListener("touchend", onTouchEnd)
        document.addEventListener("touchcancel", onTouchEnd)
      }

      function positionGhost(x, y) {
        if (!touchGhost) return
        touchGhost.style.left = x + "px"
        touchGhost.style.top = y + "px"
      }

      function onTouchMove(e) {
        if (e.touches.length !== 1) return
        e.preventDefault()
        touchMoved = true
        const t = e.touches[0]
        positionGhost(t.clientX, t.clientY)
        updateHighlight(t.clientX, t.clientY)
      }

      function updateHighlight(x, y) {
        if (lastHighlighted) {
          lastHighlighted.classList.remove("drag-over")
          lastHighlighted = null
        }
        const target = findDropTarget(x, y)
        if (target) {
          target.classList.add("drag-over")
          lastHighlighted = target
        }
      }

      function findDropTarget(x, y) {
        // Clue rows (unsolved)
        for (const row of document.querySelectorAll(".clue-row:not(.solved)")) {
          const r = row.getBoundingClientRect()
          if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return row
        }
        // Pool zones (return path)
        for (const p of document.querySelectorAll(".syllable-pool")) {
          const r = p.getBoundingClientRect()
          if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return p
        }
        return null
      }

      function onTouchEnd(e) {
        document.removeEventListener("touchmove", onTouchMove)
        document.removeEventListener("touchend", onTouchEnd)
        document.removeEventListener("touchcancel", onTouchEnd)

        if (lastHighlighted) {
          lastHighlighted.classList.remove("drag-over")
          lastHighlighted = null
        }
        if (touchGhost) {
          touchGhost.remove()
          touchGhost = null
        }
        if (touchOriginEl) {
          touchOriginEl.classList.remove("dragging")
        }

        const t = (e.changedTouches || [])[0]
        if (!t || !touchMoved || touchDragSyl === null) {
          cleanTouch()
          return
        }

        const target = findDropTarget(t.clientX, t.clientY)

        if (!target) {
          cleanTouch()
          return
        }

        // Drop on pool â†’ return syllable
        if (target.classList.contains("syllable-pool")) {
          if (touchDragSource !== "pool") {
            clueSlots[touchDragSource].splice(touchDragIdx, 1)
            pool.push(touchDragSyl)
            render()
          }
          cleanTouch()
          return
        }

        // Drop on clue row
        if (target.classList.contains("clue-row")) {
          const ci = parseInt(target.dataset.clue)
          if (isNaN(ci) || solved[ci]) {
            cleanTouch()
            return
          }
          if (touchDragSource === "pool") {
            const i = pool.indexOf(touchDragSyl)
            if (i >= 0) pool.splice(i, 1)
          } else {
            clueSlots[touchDragSource].splice(touchDragIdx, 1)
          }
          clueSlots[ci].push(touchDragSyl)
          render()
        }

        cleanTouch()
      }

      function cleanTouch() {
        touchDragSyl = null
        touchDragSource = null
        touchDragIdx = null
        touchOriginEl = null
        // Reset touchMoved after a short delay so the click handler can check it
        setTimeout(() => {
          touchMoved = false
        }, 50)
      }

      // â”€â”€ Mouse drop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function dropOnClue(ci) {
        if (dragSyl === null || solved[ci]) return
        if (dragSource === "pool") {
          const i = pool.indexOf(dragSyl)
          if (i >= 0) pool.splice(i, 1)
        } else {
          const si = clueSlots[dragSource].indexOf(dragSyl)
          if (si >= 0) clueSlots[dragSource].splice(si, 1)
        }
        clueSlots[ci].push(dragSyl)
        dragSyl = null
        dragSource = null
        render()
      }

      function returnToPool(fromSource) {
        if (dragSyl === null || fromSource === "pool") return
        const si = clueSlots[fromSource].indexOf(dragSyl)
        if (si >= 0) clueSlots[fromSource].splice(si, 1)
        pool.push(dragSyl)
        dragSyl = null
        dragSource = null
        render()
      }

      // â”€â”€ Check / Win â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function updateCheckAllBtn() {
        const btn = document.getElementById("checkAllBtn")
        if (btn) btn.disabled = solved.every(Boolean)
      }

      function checkAll() {
        if (pool.length > 0) {
          showMsg(
            `You still have ${pool.length} syllable${pool.length > 1 ? "s" : ""} left to place!`,
          )
          return
        }
        const rows = document.querySelectorAll(".clue-row")
        let anyWrong = false
        CLUES.forEach((clue, ci) => {
          if (solved[ci]) return
          const slot = clueSlots[ci]
          const correct =
            slot.length === clue.answer.length && clue.answer.every((s, i) => s === slot[i])
          const rowEl = rows[ci]
          if (correct) {
            solved[ci] = true
            rowEl.classList.remove("wrong")
          } else {
            anyWrong = true
            shake(rowEl)
            rowEl.classList.add("wrong")
            setTimeout(() => rowEl.classList.remove("wrong"), 1500)
          }
        })
        render()
        if (!anyWrong) checkWin()
      }

      let msgTimeout
      function showMsg(text) {
        const el = document.getElementById("statusMsg")
        el.textContent = text
        el.classList.add("visible")
        clearTimeout(msgTimeout)
        msgTimeout = setTimeout(() => el.classList.remove("visible"), 3000)
      }

      function shake(el) {
        el.classList.remove("wrong-shake")
        void el.offsetWidth
        el.classList.add("wrong-shake")
        setTimeout(() => el.classList.remove("wrong-shake"), 450)
      }

      function checkWin() {
        if (solved.every(Boolean)) {
          stopTimer()
          document.getElementById("finalTime").textContent = formatTime(Date.now() - startTime)
          document.getElementById("winModal").classList.add("active")
        }
      }

      function closeModal() {
        document.getElementById("winModal").classList.remove("active")
      }

      function resetPuzzle() {
        closeModal()
        pool = [...SYLLABLES]
        clueSlots = CLUES.map(() => [])
        solved = CLUES.map(() => false)
        document.getElementById("timer").textContent = "00:00"
        render()
        startTimer()
      }

      // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      document.addEventListener("DOMContentLoaded", () => {
        // Wire up mouse drop-back-to-pool for both pool elements
        ;["pool", "stickyPool"].forEach((id) => {
          const el = document.getElementById(id)
          if (!el) return
          el.addEventListener("dragover", (e) => {
            e.preventDefault()
            el.classList.add("drag-over")
          })
          el.addEventListener("dragleave", () => el.classList.remove("drag-over"))
          el.addEventListener("drop", (e) => {
            e.preventDefault()
            el.classList.remove("drag-over")
            returnToPool(dragSource)
          })
        })

        // Sticky pool: appear only when the in-card pool scrolls off screen (mobile only)
        const stickyBar = document.getElementById("stickyBar")
        const stickySpacer = document.getElementById("stickySpacer")
        const poolWrapper = document.getElementById("pool").closest(".pool-wrapper")

        const observer = new IntersectionObserver(
          (entries) => {
            if (!isMobile()) return
            const poolVisible = entries[0].isIntersecting
            stickyBar.classList.toggle("is-visible", !poolVisible)
            stickySpacer.classList.toggle("is-visible", !poolVisible)
            if (!poolVisible) updateStickyHeight()
          },
          { threshold: 0 },
        )

        observer.observe(poolWrapper)

        window.addEventListener("resize", () => {
          // If resized to desktop, always hide the sticky bar
          if (!isMobile()) {
            stickyBar.classList.remove("is-visible")
            stickySpacer.classList.remove("is-visible")
          }
          updateStickyHeight()
        })

        resetPuzzle()
      })
    </script>
  </body>
</html>
